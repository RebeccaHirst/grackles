---
title: Implementing a rapid geographic range expansion - the role of behavior and habitat changes
author: 
- '[Logan CJ](http://CorinaLogan.com)^1^*'
- '[McCune KB](https://www.kelseymccune.com/)^2^'
- '[Breen A](http://www.alexisbreen.com)^1^*'
- '[Chen N](https://popgenchenlab.github.io)^3^'
- '[Lukas D](http://dieterlukas.mystrikingly.com)^1^'
date: '`r Sys.Date()`'
output:
  html_document: 
    toc: true
    toc_depth: 5
    toc_float: 
      collapsed: false
    code_folding: hide 
  md_document: 
    toc: true
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
  github_document: 
    toc: true
bibliography: /Users/corina/GitHub/grackles/Files/MyLibrary.bib
csl: /Users/corina/GitHub/grackles/Files/behavioral-ecology.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Make code wrap text so it doesn't go off the page when Knitting to PDF
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

##### Affiliations: 
1) Max Planck Institute for Evolutionary Anthropology
2) University of California Santa Barbara
3) University of Rochester

*Corresponding author: corina_logan@eva.mpg.de

***Click [here](https://github.com/corinalogan/grackles/blob/master/Files/Preregistrations/gxpopbehaviorhabitat.Rmd) for the version-tracked reproducible manuscript (.Rmd file)***

### ABSTRACT

It is generally thought that behavioral flexibility, the ability to change behavior when circumstances change, plays an important role in the ability of a species to rapidly expand their geographic range (e.g., @lefebvre1997feeding, @griffin2014innovation, @chow2016practice, @sol2000behavioural, @sol2002behavioural, @sol2005big, @sol2007big). However, it is alternatively possible that an increase in the amount of suitable habitat can be the primary facilitator for a range expansion. Great-tailed grackles (*Quiscalus mexicanus*) are a social, polygamous species that is rapidly expanding its geographic range (@wehtje2003range) and eats a variety of human foods in addition to foraging on insects and on the ground for other natural food items (@johnson2001great). They are behaviorally flexible (@logan2016flexibilityproblem) and highly associated with human-modified environments (@johnson2001great), thus offering an opportunity to assess the role of behavior and habitat change over the course of their expansion. We first aim to compare behavior in wild-caught grackles from three populations across their range (core of the original range, a more recent population in the middle of the northern expansion front, a very recent population on the northern edge of the expansion front) to investigate whether: 1) certain behaviors (flexibility, innovativeness, exploration, and persistence) have higher averages and variances in some populations relative to others, and 2) individuals in a more recently established population exhibit more dispersal behavior (i.e., individuals are more likely to move away from their parents). Secondly, we aim to investigate whether habitat availability, not necessarily inherent species differences, can explain why great-tailed grackles are able to much more rapidly expand their range than their closest relative, boat-tailed grackles (*Q. major*) (@post1996boat, @wehtje2003range). We will examine temporal habitat changes over the past few decades using existing databases on presence/absence of both grackle species and compare habitat variables to determine whether: 3) these species use different habitats, habitat availability and connectivity has increased across their range, and what proportion of suitable habitat both species occupy. Results will elucidate whether the rapid geographic range expansion of great-tailed grackles is associated with individuals differentially expressing particular behaviors or whether the expansion is facilitated by the alignment of their natural behaviors with an increase in suitable habitat (i.e., human-modified environments).

### INTRODUCTION




### A. STATE OF THE DATA

This preregistration was written (Mar 2020) prior to collecting any data from the edge and core populations, therefore we were blind to these data. However, we were not blind to some of the data from the Arizona population: some of the relatedness data (SNPs used for Hypothesis 2 to quantify relatedness) from the middle population (Arizona) has already been analyzed for other purposes (n=57 individuals, [see](http://corinalogan.com/Preregistrations/gdispersal.html) @sevchik2019dispersal). Therefore, it will be considered secondary data: data that are in the process of being collected for other investigations. We have now collected blood samples from many more grackles in Arizona, therefore we will redo the analyses from the Arizona population in the analyses involved in the current preregistration. In May 2020, we completed data collection for other variables at the Arizona field site: [flexibility and innovation](http://corinalogan.com/Preregistrations/g_flexmanip.html) [@logan2019flexmanip], and  [exploration](http://corinalogan.com/Preregistrations/g_exploration.html) [@mccune2019exploration], and we will soon analyze this data, therefore it will also be considered secondary data. This preregistration was submitted in May 2020 to PCI Ecology for pre-study peer review.

**Level of data blindness:** Logan and McCune collect the behavioral data (H1) and therefore have seen this data for the Arizona population. Lukas has access to the Arizona data and has seen some of the summaries in presentations. Chen has not seen any data.

### B. PARTITIONING THE RESULTS

We may decide to present the results from different hypotheses in separate articles. We may also decide to test these hypotheses in additional species.

### C. HYPOTHESES

Note: There could be multiple mechanisms underpinning the results we find, however our aim here is to narrow down the relative roles of changes in behavior and changes in habitats in the range expansion of great-tailed grackles.

#### H1 (4 behaviors): Changes in behavioral traits (flexibility, innovation, exploration, and persistence) facilitate the great-tailed grackle's geographic range expansion (Fig. 1 & 2). 

**Prediction 1:** If behavior modifications are needed to adapt to new locations, then there will be a higher average and/or larger variance of at least some traits thought to be involved in range expansions (behavioral flexibility: speed at reversing a previously learned color preference based on it being associated with a food reward; innovativeness: number of options solved on a puzzle box; exploration: latency to approach/touch a novel object; and persistence: proportion of trials participated in with higher numbers indicating a more persistent individual) in the grackles sampled from the recently established population relative to the individuals sampled in the older populations (Table 1). Higher averages in behavioral traits indicate that each individual can exhibit more of that trait (e.g., they are more flexible/innovative/exploratory/persistent). Perhaps in newly established populations, individuals need to learn about and innovate new foraging techniques or find new food sources. Perhaps grackles require flexibility to visit these resources according to their temporal availability and the individual's food preferences. Perhaps solving such problems requires more exploration and persistence. Higher variances in behavioral traits indicate that there is a larger diversity of individuals in the population, which means that there is a higher chance that at least some individuals in the population could innovate foraging techniques and be more flexible, exploratory, and persistent, which could be learned by conspecifics and/or future generations.

**Prediction 1 alternative 1:** Human-modified environments are suitable habitat for grackles (e.g., @selander1961analysis, @johnson2001great, @wehtje2003range), and the amount of human-modified environments has and is increasing (e.g., @liu2020high). If the original behaviors exhibited by this species happen to be suited to the uniformity of human-modified landscapes (e.g., urban, agricultural, etc. environments are modified in similar ways across Central and North America), then the averages and/or variances of these traits will be similar in the grackles sampled from populations across their range (Table 1). This supports the hypothesis that, because this species is closely associated with human-modified environments, which may be similar across the geographic range of this species, individuals in new areas may not need to learn very much about their new environment: they can eat familiar foods and access these foods in similar ways across their range (e.g., fast food restaurant chains likely make the same food and package it in the same packaging in Central and North America, outdoor cafes and garbage cans also look the same across their range). Alternatively, it is possible that 2.9 generations at the edge site is too long after their original establishment date to detect differences in the averages and/or variances. If the sampled individuals had already been living at this location for long enough (or for their whole lives) to have learned what they need about this particular environment (e.g., there may no longer be evidence of increased flexibility/innovativeness/exploration/persisence), there may be no reason to maintain population diversity in these traits to continue to learn about this environment. We will not be able to distinguish between these two alternatives within alternative 1 because populations closer to the northern edge of this species' range were too small for us to establish such a field site.

![**Figure 1.** What plays a larger role in a rapid range expansion: behavior changes or suitable habitat changes? A visual representation of H1 (top) and H2 (bottom).](gxpopbehaviorhabitatFig1.png)

![**Figure 2.** Measuring flexibility (reversal learning), innovation (multi-access log), exploration, and persistence.](gxpopbehaviorhabitatFig2.png)

#### H2 (dispersal behavior): Changes in dispersal behavior, particularly for females, which is the sex that appears to be philopatric in the middle of the range expansion [@sevchik2019dispersal], facilitate the great-tailed grackle's geographic range expansion (Fig. 1, Table 1).

**Prediction 2:** If a change in dispersal behavior is facilitating the expansion, then we predict more dispersal at the edge: a higher proportion of individuals disperse in a more recently established population and, accordingly, fewer individuals are closely related to each other. 

**Prediction 2 alternative 1:** If the original dispersal behavior was already well adapted to facilitate a range expansion, we predict that the proportion of individuals dispersing is not related to when the population established at a particular site and, accordingly, the average relatedness is similar across populations. 

**Table 1.** Population characteristics for each of the three field sites in H1 and H2. The number of generations at a site is based on a generation length of 5.6 years for this species (@GTGRbirdlife2018) and on the first year in which this species was reported to breed at the location (@wehtje2003range for Arizona, Steve Hampton's pers. comm. reported in @pandolfino2009colonization for Woodland, California) (note: this species starts breeding at age 1). The first confirmed nest sighting in Woodland, California was reported in the Yolo Audubon Society's newsletter *The Burrowing Owl* (July 2004), which Steve Hampton shared with Logan. For Central America, there is no data on the first year in which they started breeding because this species originates in this region, therefore we used the age of the species: 800,000 years (@johnsoncicero2004new).

```{r table1, eval=TRUE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
d <- read.csv ("/Users/corina/GitHub/grackles/Files/Preregistrations/gxpopbehaviorhabitat_Table1.csv", header=F, sep=",", stringsAsFactors=F) 

library(reactable)
reactable(d, highlight=TRUE, bordered=FALSE, compact=TRUE, wrap=TRUE, resizable=TRUE,
          columns = list(
            V1 = colDef(name="Site"),
            V2 = colDef(name="Range position"),
            V3 = colDef(name="Breeding since"),
            V4 = colDef(name="Number of years breeding"),
            V5 = colDef(name="Average number of generations"),
            V6 = colDef(name="Citation")
          ))
```

#### H3 (suitable habitat GTGR & BTGR): The availability of habitat, not inherent species differences, explains why great-tailed grackles (GTGR) are able to much more rapidly expand their range than boat-tailed grackles (BTGR) (Fig. 3; @wehtje2003range, @selander1961analysis).

**Prediction 3:** GTGR and BTGR use different habitats, and the habitat of GTGR, but not that of BTGR, has increased in availability and connectivity over the past few decades.

**Prediction 4:** Over the past few decades, GTGR has increased the habitat breadth that they can occupy, whereas BTGR continues to use the same limited habitat types.

**Prediction 5:** Some inherent trait allows GTGR to expand even though both species have unused habitat available to them.

![**Figure 3.** What plays a larger role in a rapid range expansion: behavior changes or suitable habitat changes? Comparing the availability of suitable habitat between great-tailed grackles (GTGR), which are rapidly expanding their geographic range, and boat-tailed grackles (BTGR), which are not. Map credit: eBird.org.](gxpopbehaviorhabitatFig3.png)


### D. METHODS

#### Planned Sample (H1 & H2)
	
Great-tailed grackles are caught in the wild in Woodland, California and at a site to be determined in Central America. We apply colored leg bands in unique combinations for individual identification. Some individuals (~20) are brought temporarily into aviaries for behavioral choice tests, and then are released back to the wild at their point of capture. We catch grackles with a variety of methods (e.g., walk-in traps, mist nets, bow nets), some of which decrease the likelihood of a selection bias for exploratory and bold individuals because grackles cannot see the traps (i.e., mist nets). Grackles are individually housed in an aviary (each 244cm long by 122cm wide by 213cm tall) for a maximum of six months where they have *ad lib* access to water at all times and are fed Mazuri Small Bird maintenance diet *ad lib* during non-testing hours (minimum 20h per day), and various other food items (e.g., peanuts, bread) during testing (up to 4h per day per bird). Individuals are given three to four days to habituate to the aviaries and then their test battery begins on the fourth or fifth day (birds are usually tested six days per week, therefore if their fourth day occurs on a day off, they are tested on the fifth day instead). 

While the above is our ideal plan, due to restrictions around COVID-19, it may not be possible for us to accomplish all of our goals within our current funding period. We think it will be possible to collect data at one more site (which would be the second of three planned sites) and we will attempt to also include a third field site.

#### Sample size rationale (H1 & H2)
	
We test as many birds as we can during the approximately one year we spend at each site given that the birds are only brought into the aviaries during the non-breeding season (approximately September through March). It is time intensive to conduct the aviary test battery (2-6 months per bird at the Arizona field site), therefore we approximate that the minimum sample size at each site will be 20 grackles with the aim that half of the grackles tested at each site are female.
	
#### Data collection stopping rule (H1 & H2)
	
We will stop collecting data on wild-caught grackles in H1 and H2 (data for H3 are collected from the literature) once we have completed one year at each of the California and Central America sites (likely complete in summer 2022), which coincides with the period in which we currently have funding (until early 2023). If we are not able to collect data at a third site, we will attempt to collect more data during a second year at the second site (Woodland, CA).

#### Protocols and open materials

  - Experimental protocols for H1 are online [here](https://docs.google.com/document/d/1oqucJ4mH-glh9Hv9JaiDSyhEGi0yVpMuqqzqR2IwQeA/edit?usp=sharing).
  
  - **Flexibility** protocol (from @logan2019flexmanip) using reversal learning with color tubes. Grackles are first habituated to a yellow tube and trained to search for hidden food. A light gray tube and a dark gray tube are placed on the table or floor: one color always contains a food reward (not visible by the bird) while the other color never contains a reward. The bird is allowed to choose one tube per trial. An individual is considered to have a preference if it chose the rewarded option at least 85% of the time (17/20 correct) in the most recent 20 trials (with a minimum of 8 or 9 correct choices out of 10 on the two most recent sets of 10 trials). We use a sliding window in 1-trial increments to calculate whether they passed after their first 20 trials. Once a bird learns to prefer one color, the contingency is reversed: food is always in the other color and never in the previously rewarded color. The flexibility measure is how many trials it takes them to reverse their color preference using the same passing criterion.
  
  - **Innovativeness** protocol (from @logan2019flexmanip and based on the experimental design by @auersperg_flexibility_2011) using a multi-access log. Grackles are first habituated to the log apparatus with all of the doors locked open and food inside each locus. After habituation, the log, which has four ways of accessing food (pull drawer, push door, lift door up, swing door out), is placed on the ground and grackles are allowed to attempt to solve or successfully solve one option per trial. Once a bird has successfully solved an option three times, it becomes non-functional (the door is locked open and there is no food at that locus). The experiment ends when all four loci become non-functional, if a bird does not come to the ground within 10 min in three consecutive test sessions, or if a bird does not obtain the food within 10 min (or 15 min if the bird was on the ground at 10 min) in three consecutive test sessions.

  - **Exploration** protocol (from @mccune2019exploration) for exploration of a novel object. A familiar object (that contains no food) is placed in the center of the bird's aviary, while maintenance diet is available at a far end of the aviary away from the object, for 45 min. This is immediately followed by the same set up with a novel object instead of a familiar object. Test sessions are video recorded and experimenters are out of view of the bird during the sessions. This assay is conducted at Time 1 (3-6 days after the bird arrives in the aviary) and Time 2 (1 week after Time 1) with the same novel object (to control for potential differences in perceived threat or attraction between objects) to determine whether measures are repeatable across individuals. Note: we might make two modifications to this protocol as a result of analyzing the results from the Arizona population: 1) we may reduce the session time from 45 min to something shorter if all grackles who came to the ground did so in <45 min in Arizona, and 2) we may replace the novel object with a novel environment - we will choose the one that correlates with boldness measures in Arizona. If both correlate with boldness, we will choose the novel object because it is a simpler test.
  
  - **Persistence** is measured as the proportion of trials participated in during the flexibility and innovativeness experiments (after habituation, thus it is not confounded with neophobia). The higher the number, the more persistent they are. This measure indicates that those birds who do not participate as often are less persistent in terms of their persistence with engaging with the task. We generally offer a grackle the chance to participate in a trial for 5 min. If they don't participate within that time, we record -1 in the data sheet, the apparatus is removed and the trial is re-attempted later. 
  
  - **Dispersal:** DNA is collected from the grackles, processed, and analyzed for pairwise relatedness using ddRADseq and Stacks as in @sevchik2019dispersal ([protocol](http://corinalogan.com/Preregistrations/gdispersal.html)).
  
  - **Suitable habitat:** We will conduct ecological niche modeling to investigate grackle presence as it overlaps with suitable habitat across their range. Grackles will be considered as present or absent in a particular geographic area based on sightings reported at eBird.org. We identified suitable habitat variables from @selander1961analysis, @johnson2001great, and @post1996boat (e.g., types of suitable land cover including coastal marsh, coastal plain, crop land, grassland, brush, mangrove), and we added additional variables relevant to our hypotheses (e.g., distance from road/water body/wetland/water treatment plant, distance to next suitable habitat patch, distance to nearest conspecific population). A suitable habitat map will be generated across the Americas using GIS.

#### Open data (H1 & H2)

When the study is complete, the data will be published in the Knowledge Network for Biocomplexity's data repository.

#### Randomization and counterbalancing (H1 & H2)

**Experimental order:** The order of experiments, reversal learning or multiaccess log, will be counterbalanced across birds within a site.

**Reversal learning:** The first rewarded color in reversal learning is counterbalanced across birds at each site. The rewarded option is pseudorandomized for side (and the option on the left is always placed first). Pseudorandomization consists of alternating location for the first two trials of a session and then keeping the same color on the same side for at most two consecutive trials thereafter. A list of all 88 unique trial sequences for a 10-trial session, following the pseudorandomization rules, will be generated in advance for experimenters to use during testing (e.g., a randomized trial sequence might look like: LRLLRRLRLR, where L and R refer to the location, left or right, of the rewarded tube). Randomized trial sequences will be assigned randomly to any given 10-trial session using a random number generator (random.org) to generate a number from 1-88.

#### Blinding during analysis

Blinding is usually not involved in the final analyses because the experimenters collect the data (and therefore have seen some form of it) and run the analyses. Hypotheses- and data-blind video coders are recruited to conduct interobserver reliability of 20% of the videos for each experiment.


### E. ANALYSIS PLAN

We use **simulations** and design customized **models** to determine what sample sizes allow us to detect differences between sites (see chapter 5.3 in @bolker2008ecological for why simulations perform more powerful power analyses). We do not plan to **exclude** any data and if there are **missing** data (e.g. if a bird participated in one of the two experiments, then it will only be included in those analyses for which it has data). Analyses will be conducted in R (current version `r getRversion()`; @rcoreteam) and Stan (version 2.18, @carpenter2017stan). 

##### Interobserver reliability of dependent variables

To determine whether experimenters coded the dependent variables in a repeatable way, hypothesis-blind video coders will first be trained in video coding the dependent variables (reversal learning and multiaccess log: whether the bird made the correct choice or not; exploration: latency to approach), requiring a Cohen's unweighted kappa (reversal and multiaccess categorical variables) or an intra-class correlation coefficient (ICC; exploration continuous variable) of 0.90 or above to pass training. This threshold indicates that the two coders (the experimenter and the video coder) agree with each other to a high degree (kappa: @landis1977measurement, using the psych package in R @psych; ICC: @hutcheon2010random, using the irr package in R: @gamer2012package). After passing training, the video coders will code 20% of the videos for each experiment and the kappa and ICC will be calculated to determine how objective and repeatable scoring was for each variable, while noting that the experimenter has the advantage over the video coder because watching the videos is not as clear as watching the bird participate in the trial from the aisle of the aviaries. The unweighted kappa is used when analyzing a categorical variable where the distances between the numbers are meaningless (0=incorrect choice, 1=correct choice, -1=did not participate), and the ICC is used for continuous variables where distances are meaningful (e.g., if coders disagree by a difference of 2 s rather than 5 s, this is important to account for).

```{r ior, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
library(irr) #ICC package

#### FLEXIBILITY (reversal learning)

# did video coder pass interobserver reliability training? 
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
cohen.kappa(data[,c(3,5)], w=NULL,n.obs=NULL,alpha=.05,levels=NULL) 

# video coder score for 20% of videos =  
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
cohen.kappa(data[,c(3,5)], w=NULL,n.obs=NULL,alpha=.05,levels=NULL) 


#### INNOVATIVENESS (multiaccess log)

# did video coder pass interobserver reliability training? 
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
cohen.kappa(data[,c(3,5)], w=NULL,n.obs=NULL,alpha=.05,levels=NULL) 

# video coder score for 20% of videos =  
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
cohen.kappa(data[,c(3,5)], w=NULL,n.obs=NULL,alpha=.05,levels=NULL) 


#### EXPLORATION (latency to approach a novel object)

# did video coder pass interobserver reliability training? 
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
icc(data[,c(3,5)], model="oneway", type="consistency", unit="single", conf.level=0.95) 

# video coder score for 20% of videos =  
data <- read.csv("/Users/corina/ownCloud/Documents/Experiments/Interobserver Reliability/InterObsRelGoNoGoLCBrynna.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(data)  #Check to make sure it looks right
# Note: c(3,5) is telling R to look at columns 2 and 3 and compare them. Double check this:
data[,3] #coder 1 (live coder)
data[,5] #coder 2 (video coder)
icc(data[,c(3,5)], model="oneway", type="consistency", unit="single", conf.level=0.95) 
```


#### H1: behavior across the range

*Response variables*

1) Flexibility: number of trials to reverse a color preference. 

2) Innovativeness: total number of loci solved on the multiaccess log (maximum=4)

3) Exploration: Latency to approach up to 20cm of an object (novel or familiar, that does not contain food) in a familiar environment (that contains maintenance diet away from the object) - OR - closest approach distance to the object (choose the variable with the most data for the analysis).

4) Persistence: proportion of trials participated in during the flexibility and innovativeness experiments

One model will be run for each response variable

*Explanatory variable*

There is no explanatory variable: we will conduct pairwise comparisons across sites as described in the next section.

##### Hypothesis-specific mathematical model

Following procedures in @statrethinkingbook, we constructed a **hypothesis-appropriate mathematical model** for each of the response variables that examines differences in the response variable between sites. These models take the form of:

y ~ $\alpha$[site]

y is the response variable (flexibility, innovation, exploration, or persistence). There will be one intercept, $\alpha$, per site and we will estimate the site's average and standard deviation of the response variable. 

We will then perform pairwise contrasts to determine at what point we will be able to detect differences between sites by manipulating sample size, and $\alpha$ means and standard deviations. Before running the simulations, we decided that a model would detect an effect if 89% of the difference between the two posterior distributions was on the same side of zero (following @statrethinkingbook). We ran these analyses in R (current version `r getRversion()`; @rcoreteam) and used the following R packages: rethinking (@rethinking2020), rstan (@rstan), and Rcpp (@rcpp).

##### Flexibility analysis

**Model and simulation**

Expected values for reversal learning using color tubes (mean, standard deviation, and range of number of trials to reverse a color preference) were based on previously published data on great-tailed grackles (@logan2016behavioral). This data indicates that the average number of trials to reverse a preference is 91 and the standard deviation is 21 (n=7 grackles). The $\sigma$ prior is set to produce only positive values that encompass the range of values shown by the Santa Barbara grackles (reversing in 70-130 trials, 130 trials-91 mean is about 40 trials).

y ~ $\alpha$[site] *[the model]*

$\alpha$[site] ~ Normal($\mu$,$\sigma$) *[$\alpha_1$ prior]*

$\mu$ ~ Normal(91,21) *[$\mu$ prior]*

$\sigma$ ~ Uniform(0,40) *[$\sigma$ prior]*

```{r modelflexibility, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
library(rethinking)
library(rstan)

#Plot priors to make sure the prior behaves as expected (p.82 Rethinking)
curve( dnorm( x , 91 , 21 ) , from=20 , to=200 ) #mu result as expected
curve( dunif( x , 0 , 50 ) , from=-10 , to=60 ) #sigma result as expected

#Prior predictive simulation (p.82 Rethinking)
sample_mu <- rnorm( 1e4 , 91 , 21 )
sample_sigma <- runif( 1e4 , 0 , 40 )
prior_t <- rnorm( 1e4 , sample_mu , sample_sigma ) 
dens( prior_t ) #Result: behaving as expected


### SIMULATION: Manipulate mu mean, mu sd, and n (grackles)
#Simulate data for the model
n <- 60 #number of grackles in total across all sites (~20/site; AZ=20)
sites <- matrix(nrow=n,ncol=4) #store data here
colnames(sites)<-c("trials","mu","sigma","site")

for (i in 1:(n/3)){
  mu1 <- rnorm( 1 , 91 , 22 ) #mu for site 1
  sigma1 <- runif( 1 , 0 , 40 ) #sigma for site 1
  trials <- rnorm(1,mu1,sigma1) #distribution for trials
  
  sites[i,1]<-trials
  sites[i,2]<-mu1
  sites[i,3]<-sigma1
  sites[i,4]<-1 #site
}

for (i in ((n/3)+1):((n/3)+(n/3))){
  mu2 <- rnorm( 1 , 120 , 22 ) #mu for site 2
  sigma2 <- runif( 1 , 0 , 40 ) #sigma for site 2
  trials <- rnorm(1,mu2,sigma2) #distribution for trials
  
  sites[i,1]<-trials
  sites[i,2]<-mu2
  sites[i,3]<-sigma2
  sites[i,4]<-2 #site
}

for (i in ((n/3)+(n/3)+1):n){
  mu3 <- rnorm( 1 , 77 , 22 ) #mu for site 3
  sigma3 <- runif( 1 , 0 , 40 ) #sigma for site 3
  trials <- rnorm(1,mu3,sigma3) #distribution for trials
  
  sites[i,1]<-trials
  sites[i,2]<-mu3
  sites[i,3]<-sigma3
  sites[i,4]<-3 #site
}

### THE MODEL
dat <- list(trials = as.numeric(sites[,1]),
            site = as.integer(sites[,4])
) #This sets up the data sheet with the simulated data that the model will run on

s1 <- ulam(
  alist(
trials ~ dnorm(mu[site],sigma),
mu[site] ~ dnorm(91,21),
sigma ~ dunif(0,40)
),data=dat, log_lik=TRUE, messages=FALSE) #This is the model

#Plot it
labels <- paste( "mu[" , 1:3 , "]:" , levels(dat$site) , sep="" ) 
plot( precis( s1 , depth=2 , pars="mu" ) , labels=labels ,  xlab="expected trials to reverse" ) #contrasts plot p.157

#Summary data
precis(s1,depth=2) #depth=2 means to show any vector parameters (p.156)

#Compute pairwise contrasts
#Comparing sites 1 and 2
post1 <- extract.samples(s1) 
post1$diff_12 <- post1$mu[,1] - post1$mu[,2] #subtract mu for site 2 from mu for site 1. col1=site 1, col2=site 2
precis(post1,depth=2) #look at the last row: diff_12: this is the expected difference between the distributions of mu at sites 1 and 2. (p.156) The distribution crosses 0, which means that there are no differences between the sites (because subtracting distribution 1 from distribution 2 should result in all negative or all positive values if the two distributions are consistently different from each other)
#hist(post1$diff_12) #another way of visualizing it

#Comparing sites 1 and 3
post2 <- extract.samples(s1) 
post2$diff_13 <- post2$mu[,1] - post2$mu[,3] 
precis(post2,depth=2)

#Comparing sites 2 and 3
post3 <- extract.samples(s1) 
post3$diff_23 <- post3$mu[,2] - post3$mu[,3] 
precis(post3,depth=2)

###To make the model work, need to set up a few things... (this took me a few days because at every stage there is an error message and it isn't clear what the problem is or what to do next)

###Update R
#install installr package
#updateR(TRUE) #didn't work bc it can't find my R folder on my computer
#updateR(fast = FALSE, browse_news, install_R, copy_packages, copy_Rprofile.site, keep_old_packages, update_packages, start_new_R, quit_R, print_R_versions = TRUE, GUI = TRUE, to_checkMD5sums = FALSE, keep_install_file = FALSE, download_dir = "/Users/corina/Library/R", silent = FALSE, setInternet2 = TRUE, cran_mirror = "https://cran.rstudio.com/") #didn't work bc it can't find my R folder on my computer
#manually updated R and reinstalled packages

###Install rethinking
#install package devtools
#devtools::install_github("rmcelreath/rethinking",ref="Experimental")

###Install xcode (first download the app from the app store)
#In terminal, type: "xcode-select --install"

###Get STAN working https://github.com/rmcelreath/rethinking
#Install C++ toolchain and configuration https://github.com/stan-dev/rstan/wiki/Installing-RStan-from-source-on-a-Mac
#install.packages("Rcpp", repos = "https://rcppcore.github.io/drat") 
#Then install rstan per instructions at the previous link

###Now we're ready to go!
```

We then ran the **mathematical model** and performed pairwise contrasts and determined that we will be able to detect differences between sites with a sample size of 15 at each site if the average number of trials to reverse a preference differs by >13 trials, and the standard deviation is a maximum of 21 at each site (Table 2). For a sample size of 20 at each site, which is more like what we expect, we will be able to detect site differences if the average number of trials to reverse a preference differs by >11 trials, and the standard deviation is a maximum of 23 at each site  (Table 2).

**Table 2.** Simulation outputs from varying sample size (n), and $\alpha$ means and standard deviations. From the pairwise contrasts, if the difference between the distributions crosses zero (yes), then we are not able to detect differences between the two sites. If they do not cross zero (no), then we are able to detect differences between the two sites. Note that for latency, there is no mu_sd, but rather one phi that is the same for all sites.

```{r tableparam, eval=TRUE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
d <- read.csv ("/Users/corina/GitHub/grackles/Files/Preregistrations/gxpopbehaviorhabitat_Table2.csv", header=F, sep=",", stringsAsFactors=F) 

library(reactable)
reactable(d, highlight=TRUE, bordered=FALSE, compact=TRUE, wrap=TRUE, resizable=TRUE,
          columns = list(
            V1 = colDef(name="Response variable"),
            V2 = colDef(name="n"),
            V3 = colDef(name="mu1"),
            V4 = colDef(name="mu2"),
            V5 = colDef(name="mu3"),
            V6 = colDef(name="mu1_sd"),
            V7 = colDef(name="mu2_sd"),
            V8 = colDef(name="mu3_sd"),
            V9 = colDef(name="Difference crosses zero? S1-S2"),
            V10 = colDef(name="Difference crosses zero? S1-S3"),
            V11 = colDef(name="Difference crosses zero? S2-S3"),
            V12 = colDef(name="Notes")
          ))
```

**Results (using our actual data)**

We will analyze our data using the above model once all of the data have been collected.


##### Innovation analysis

**Model and simulation**

Expected values for the number of options solved on the multiaccess log were set to 0-4 (out of 4 options maximum) because this apparatus had been used on two species of jays who exhibited individual variation in the number of loci solved between 0-4 (California scrub-jays and Mexican jays: @mccune2018cognition, @mccune2019captive).

locisolved ~ Binomial(4, p) *[likelihood]*

logit(p) ~ $\alpha$[site]  *[model]*

locisolved is the number of loci solved on the multiaccess box, 4 is the total number of loci on the multiaccess box, p is the probability of solving any one locus across the whole experiment, $\alpha$ is the intercept, and each site gets its own intercept. After running simulations, we identified the following distribution to be the most likely priors for our expected data:

$\alpha$ ~ Normal(0,1) *[$\alpha$ prior]*

We used a normal distribution for $\alpha$ because it is a sum (see Figure 10.6 in @statrethinkingbook) and a logit link to ensure the values are between 0 and 1. We set the mean to 0 on a logit scale, which means an individual solves 2 loci on average on the actual scale at a probability of 0.5.

```{r innovation, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
library(rethinking)
library(rstan)

### SIMULATION
#Figuring out probability, p
s1mean <- 2 #site 1: solves on average 2 loci 
s2mean <- 1.6 #site 2: solves on average 1.6 loci
s3mean <- 3.6 #site 3: solves on average 1.6 loci

s1mean <- log((s1mean/4)/(1-(s1mean/4))) #convert to the logit scale: log(p/1-p) p=4/probability to solve a given locus (4 because max 4 loci, so 2 loci solved / 4 total loci = 0.5 probability)
s2mean <- log((s2mean/4)/(1-(s2mean/4))) 
s3mean <- log((s3mean/4)/(1-(s3mean/4))) 

#Figuring out alpha prior
probabilities<-inv_logit(rnorm(10000,mean=0,sd=0.3))
loci <- vector()
for(i in 1:10000) {loci[i]<-rbinom(1,size=4,prob=probabilities[i])}
mean(loci) #this is the mean number of loci solved
hist(loci) #We expect a bell curve with most of the individuals being average at solving loci (at the mean=2 loci) and some being more innovative while others are less. Minimum SD=0.3

#Figuring out how much noise we expect (sd in alpha) = 0.4
hist(inv_logit(rnorm(10000,mean=0,sd=1))) #it is spread out along the x axis so the many individuals in the ends are going to have different probabilities from the pop mean
hist(inv_logit(rnorm(10000,mean=0,sd=0.5))) #this is much narrower, thus most of the individuals will match the pop mean and this reduces noise

#Result = in the simulation alpha sd should not be larger than 1 because at 1 it ranges from a probability of solving 0.12-0.88 loci which is basically the min and max possible range. But since this is the sd, we want it narrower than the full range (so it isn't a flat prior), so set it to something like 0.5


#RUN SIMULATION WITH PARAMETERS (this is the simulated data that the model (below) will use) Generate values for simulated individuals from 3 simulated sites: vary the alpha site mean (expected number of loci solved and whether sites differ) and alpha sd (the noise in the population in the number of loci solved), and sample size
asd <- 0.3 #alpha sd for the population. We set this smaller than what we had it above bc we wanted to make it so individuals were not equally likely to have similar results
s1mean <- 1.9 #site 1: alpha mean: solves on average 2 loci 
s2mean <- 2.1 #site 2: alpha mean: solves on average 1.6 loci
s3mean <- 2.2 #site 3: alpha mean: solves on average 3.6 loci
n <- 60

s1mean <- log((s1mean/4)/(1-(s1mean/4))) #convert to the logit scale: log(p/1-p) p=4/probability to solve a given locus (4 because max 4 loci, so 2 loci solved / 4 total loci = 0.5 probability)
s2mean <- log((s2mean/4)/(1-(s2mean/4))) 
s3mean <- log((s3mean/4)/(1-(s3mean/4))) 

sites<-matrix(nrow=n,ncol=6)
colnames(sites)<-c("loci","site","probability","logit base value","base probability","logit probability")
for (i in 1:n/3) {
  s1 <- rnorm(1,s1mean,0.5) #n, mean, sd of probability of solving a locus. SD is the noise
  p <- s1
  sites[i,1]<-sum(rbinom(50,1,inv_logit(p)/12.5)) #50 trials (drawing 50 times (the highest number of trials an individual could get is probably 50 trials). Each trial is an opportunity to solve a locus and they can only solve 1 locus per trial. Sum for how many of the loci in total did they solve across the 50 trials
  ifelse(sites[i,1]>4,sites[i,1]<-4,sites[i,1]<-sites[i,1])
  sites[i,2]<-1 #column: site 1
  sites[i,3]<-inv_logit(p) #column: p (probability)
  sites[i,4]<-s1 #logit base value of alpha (for the intercept for this site)
  sites[i,5]<-inv_logit(s1) #base probability is the inverse logit of the previous column
  sites[i,6]<-p #logit probability
}

for (i in ((n/3)+1):((n/3)+(n/3))){
  s2 <- rnorm(1,s2mean,0.5) #n, mean, sd of probability of solving a locus. SD is the noise
  p <- s2
  sites[i,1]<-sum(rbinom(50,1,inv_logit(p)/12.5)) 
  ifelse(sites[i,1]>4,sites[i,1]<-4,sites[i,1]<-sites[i,1])
  sites[i,2]<-2 #column: site 2
  sites[i,3]<-inv_logit(p)
  sites[i,4]<-s2
  sites[i,5]<-inv_logit(s2)
  sites[i,6]<-p 
}

for (i in ((n/3)+(n/3)+1):n){
  s3 <- rnorm(1,s3mean,0.5) #n, mean, sd of probability of solving a locus. SD is the noise
  p <- s3
  sites[i,1]<-sum(rbinom(50,1,inv_logit(p)/12.5)) 
  ifelse(sites[i,1]>4,sites[i,1]<-4,sites[i,1]<-sites[i,1])
  sites[i,2]<-3 #column: site 3
  sites[i,3]<-inv_logit(p)
  sites[i,4]<-s3
  sites[i,5]<-inv_logit(s3)
  sites[i,6]<-p 
}

#Have a look at the relationship to double check the relationship is as expected when back translating to the original units
plot(sites[,3],sites[,1]) #positive relationship as expected


### RUN MODEL
#don't change alpha or beta parameters here because they are changed above
dat <- list(locisolved = sites[,1],
            site = sites[,2]
              )

m1 <- ulam( alist(
  locisolved ~ dbinom(4,p) , #4 loci, p=probability of solving a locus
  logit(p) <- a[site] , #site=random effect
  a[site] ~ dnorm(0,1) #each site gets its own intercept, set to sd to 1 to make a slightly narrower distribution around the mean 2 loci solved
) , data=dat , chains=4 , log_lik=TRUE )

precis(m1,depth=2)
#mean(sites[1:8,1])
#mean(sites[9:16,1])

#Figure out alpha sd: check posterior for p to look at the distribution of probabilities that are probable (this is where we would figure out whether we need to tweak alpha sd in m1) (p.328)
#prior <- extract.prior(m1,n=1e4)
#p <- inv_logit(prior$a) #convert from logit to actual probability
#dens(p,adj=0.1)
#result1: it was a normal curve with a peak at 0.5

#Plot it
labels <- paste( "a[" , 1:3 , "]:" , levels(dat$site) , sep="" ) 
plot( precis( m1 , depth=2 , pars="a" ) , labels=labels ,  xlab="expected loci solved" ) #contrasts plot p.157

#Compute pairwise contrasts
#Comparing sites 1 and 2
post1 <- extract.samples(m1) 
post1$diff_12 <- post1$a[,1] - post1$a[,2] #subtract mu for site 2 from mu for site 1. col1=site 1, col2=site 2
precis(post1,depth=2) #look at the last row: diff_12: this is the expected difference between the distributions of mu at sites 1 and 2. (p.156) The distribution crosses 0, which means that there are no differences between the sites (because subtracting distribution 1 from distribution 2 should result in all negative or all positive values if the two distributions are consistently different from each other)

#Comparing sites 1 and 3
post2 <- extract.samples(m1) 
post2$diff_13 <- post2$a[,1] - post2$a[,3] 
precis(post2,depth=2)

#Comparing sites 2 and 3
post3 <- extract.samples(m1) 
post3$diff_23 <- post3$a[,2] - post3$a[,3] 
precis(post3,depth=2)
```

We then ran the **mathematical model** and performed pairwise contrasts and determined that we will be able to detect differences between sites with a sample size of 15 at each site if the average number of loci solved differs by 1.2 loci or more and the standard deviation is generally a maximum of 0.9 at each site (Table 2). For a sample size of 20 at each site, we will be able to detect site differences if the average number of loci solved differs by 0.7 of a locus or more and the standard deviation is generally a maximum of 1 at each site (Table 2). Note: the Arizona sample size is 11 for the multiaccess log and 17 on a similar multiaccess box.

**Results (using our actual data)**

We will analyze our data using the above model once all of the data have been collected.


##### Exploration analysis

**Model and simulation**

We modeled the average latency to approach an object and compared these between sites. We simulated data and set the model as follows: 

latency ~ gamma-Poisson($\lambda_i$, $\phi$) *[likelihood]*

log($\lambda_i$) ~ $\alpha$[site]  *[the model]*

latency is the average latency to approach an object, $\lambda_i$ is the rate (probability of approaching the object in each second) per bird (and we take the log of it to make sure it is always positive; birds with a higher rate have a smaller latency), $\phi$ is the dispersion of the rates across birds, and $\alpha$ is the intercept for the rate per site. 

Expected values for the latency to approach a novel object range from 0-2700 sec, which encompasses the time period during which they are exposed to the object (sessions last up to 45 min). However, we do not provide an upper limit for the model because those birds that do not approach within 2700 sec would eventually have had to approach the object to access their food (it is just that sessions did not run that long). After running simulations, we identified the following distribution and priors to be the most likely for our expected data:

$\phi$ ~ 1/(Exponential(1)) *[$\phi$ prior]*

$\alpha$ ~ Normal(1350,500) *[$\alpha$ prior]*

We used a gamma-Poisson distribution for latency because it constrains the values to be positive. For $\phi$, we used an exponential distribution because it is standard for this paramter. We used a normal distribution for $\alpha$ because it is a sum with a large mean (see Figure 10.6 in @statrethinkingbook). We estimate that the grackles might approach the object at any time in the session, therefore we held the $\alpha$ mean of 1350 sec in mind as we conducted the modeling. We set the $\alpha$ standard deviation to 500 because this puts the range of seconds for the distribution in the possible range.

```{r exploration, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
library(rethinking)
library(rstan)
library(Rcpp)

#Get citations for packages
options(citation.bibtex.max=999) #this makes it so that citation() only shows up in bibtex format
citation("Rcpp")
citation("rstan")
citation("rethinking")

#Checking to make sure the alpha prior is as expected
hist(rnorm(10000,mean=1350,sd=500)) #this gives us a range from 0-3000 sec, which is what is possible

#Looked into using a poisson rather than a gamma poisson distribution, but poisson only has one paramater (lambda) and it doesn't let me change the shape of the curve. So I need to use a gamma poisson distribution
hist(rpois(1000,1350)) #1000=sample size, mean=1350 sec

### SIMULATIONS: GAMMA-POISSON
#FYI this is a useful resource for gamma poisson distributions https://en.wikipedia.org/wiki/Gamma_distribution
#Lambda * phi = variance. NOTE: lambda=mu, and phi is sometimes called scaling factor or scale

#Find the right mean seconds to approach (alpha mean) and phi
hist(rgampois(10000,2000,1000),breaks=30) #10000 samples, mu (average seconds to approach), scaling factor=1000 that gives variance (variance=mu * scale). 7.2=log of 1350 sec. Look at the shape of the curve and adjust the mean and scale until you get the shape you want. I want a flat line
sum(rgampois(10000,2000,1000)>2700) #use this to see how many of the 1000 simulated grackles did not come down in the 2700 sec session. Estimate 25% of the grackles will not participate so 250 grackles. =2500 
median(rgampois(10000,2000,1000)) #check the median to see if it is around 1350 sec. =1652
var(rgampois(10000,2000,1000)) #variance of the 1000 individuals in the sample above, mean=2000 seconds, phi=1000. SD=sqrt of variance
#Result: log(lambda)=alpha = 2000 seconds (this is alpha mu), phi=1000

#Simulate the data
n <- 60 #number of individuals
phi <- 1000 #this gives us a distribution that we expect (long right tail)

am1<-4.6 #site 1 alpha mean: 4.6=log of 100 sec (seconds to approach an object), 110s=4.7
am2<-6.3 #site 2 alpha mean: 6.2=log of 500 sec, 550s=6.3, 600s=6.4
am3<-7.3 #site 3 alpha mean: 7.1=log 1200 sec, 1339s=7.2, 1480s=7.3, 1636s=7.4

sites<-matrix(nrow=n,ncol=2)
colnames(sites)<-c("latency","site")

for (i in 1:n/3){
  lambda <- exp(am1) #the linear model for site 1
  latency <- rgampois(1,lambda,phi) #this is the latency per individual
  sites[i,1]<-latency
  sites[i,2]<-1 #site 1
}

for (i in ((n/3)+1):((n/3)+(n/3))){
  lambda <- exp(am2)
  latency <- rgampois(1,lambda,phi)
  sites[i,1]<-latency
  sites[i,2]<-2 #site 2
}

for (i in ((n/3)+(n/3)+1):n){
  lambda <- exp(am3)
  latency <- rgampois(1,lambda,phi)
  sites[i,1]<-latency
  sites[i,2]<-3 #site 3
}

sites[sites[,1]>2700,1]<-2701 #make all non-participatory birds have a 2701

#In case I want to check what the data look like
#mean(sites[sites[,2]==1,1]) #site 1
#mean(sites[sites[,2]==2,1]) #site 2
#mean(sites[sites[,2]==3,1]) #site 3

#hist(sites[sites[,2]==1,1],breaks=30) #site 1
#hist(sites[sites[,2]==2,1],breaks=30) #site 2
#hist(sites[sites[,2]==3,1],breaks=30) #site 1

#Maybe we want to compare the proportion of observations below the median between 2 sites?
#median(sites[sites[,2]!=3,1]) # 62
#sum(sites[sites[,2]==1,1]>62) # 7
#sum(sites[sites[,2]==2,1]>62) # 13

### RUN THE MODEL
dat <- list(latency = as.integer(sites[,1]),
            site = as.integer(sites[,2])
)

m2 <- ulam(
  alist(
    latency ~ dgampois(lambda, phi),
    log(lambda) <- a[site],
    a[site] ~ dnorm(1,1),
    phi ~ dexp(1)
  ),data=dat, log_lik=TRUE, messages=FALSE)

###NOTE: this model doesn't work on my computer...something about the rcpp package needing to be installed from scratch? Follow instructions here: https://github.com/stan-dev/rstan/wiki/How-to-build-rstan-package%3F


#Plot it (contrasts plot p.157)
labels <- paste( "a[" , 1:3 , "]:" , levels(dat$site) , sep="" ) 
plot( precis( m2 , depth=2 , pars="a" ) , labels=labels ,  xlab="expected latency" )

#Compute pairwise contrasts
#Comparing sites 1 and 2
post1 <- extract.samples(m2) 
post1$diff_12 <- post1$a[,1] - post1$a[,2] #subtract mu for site 2 from mu for site 1. col1=site 1, col2=site 2
precis(post1,depth=2) #look at the last row: diff_12: this is the expected difference between the distributions of mu at sites 1 and 2. (p.156) The distribution crosses 0, which means that there are no differences between the sites (because subtracting distribution 1 from distribution 2 should result in all negative or all positive values if the two distributions are consistently different from each other)

#Comparing sites 1 and 3
post2 <- extract.samples(m2) 
post2$diff_13 <- post2$a[,1] - post2$a[,3] 
precis(post2,depth=2)

#Comparing sites 2 and 3
post3 <- extract.samples(m2) 
post3$diff_23 <- post3$a[,2] - post3$a[,3] 
precis(post3,depth=2)
```

We then ran the **mathematical model** and performed pairwise contrasts and determined that we will be able to detect differences between sites with a sample size of 15 at each site or 20 at each site if the average latency to approach the object differs by at least 450 sec at each site (Table 2). We kept the shape of the curve (which can be thought of as similar to a standard deviation) the same across sites because we do not think this assumption will change across populations (i.e., there will be lots of variation at each site with some individuals approaching almost immediately, others in the middle of the session, and others near the end).

**Results (using our actual data)**

We will analyze our data using the above model once all of the data have been collected.


##### Persistence analysis

**Model and simulation**

Expected values for the number of trials not participated in could range from 0-125 (likely maxima: 300 trials reversal learning [70 trials initial discrimination, 130 trials reversal, ~100 non-participation trials], 50 trials multiaccess log [~25 non-participation trials]). After running simulations, we identified the following distribution and priors most likely for our expected data:

participated ~ Binomial(totaltrials, p) *[likelihood]*

logit(p) ~ $\alpha$[site]  *[model]*

participated indicates whether the bird participated or not in a given trial, total trials is the total number  of trials offered to the individual (those participated in plus those not participated in), p is the probability of participating in a trial, $\alpha$ is the intercept, and each site gets its own intercept. We used a logit link to constrain the output to between 0 and 1. After running simulations, we identified the following distribution and priors most likely for our expected data:

$\alpha$ ~ Normal(0,0.5) *[$\alpha$ prior]*

We used a normal distribution for $\alpha$ because it is a sum (see Figure 10.6 in @statrethinkingbook). We set the mean to 0 (on a logit scale, which is a probability of 0.5 that a bird will participate in every other trial on average on the actual scale).

```{r modelpersistence, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
library(rethinking)
library(rstan)
library(Rcpp)

#SIMULATE DATA
#Make sure the simulation stays in the correct range
hist(rnorm(n,mean=275,sd=27)) #mean number of total trials, based on the estimation that they will require ~215 trials to complete both experiments if they participate in all trials. sd=27 makes the range 190-360, which is what we would expect

#Figure out the priors: alpha mean
hist(inv_logit(rnorm(2000,mean=0,sd=1.5))) #what do we expect the probability of participating to be? A flat line. And that's what this gets us. 2000 sample size, mean=0 (0.5 probability on inverse logit scale), sd is of our expectation of the prior - doesn't have to have anything to do with what happens in the actual population. The larger the SD, the less certain we are about what we expect

#Manipulate these variables
n <-60 #number of grackles in total across all 3 sites
site1mean<-0.67 #site 1 alpha mean: proportion of trials participated in
site2mean<-0.75
site3mean<-0.83
asd1 <- 0.25 #site 1 alpha sd: proportion of trials participated in
asd2 <- 0.25 #site 2 alpha sd
asd3 <- 0.25 #site 3 alpha sd

#Populate the simulated data sheet
testdata <- matrix(nrow=n,ncol=5)
testdata <- as.data.frame(testdata)
colnames(testdata) <- c("individual","site","participated","optout","totaltrials")
testdata$individual <- c(1:n) #unique identifier for each individual
testdata$site <- c(rep(1,n/3),rep(2,n/3),rep(3,n/3)) #assign 3 sites
testdata$totaltrials <- c(round(rnorm(n,mean=275,sd=27),0)) #mean number of total trials=275 at each site with some variation (sd=15) among individuals, but not across sites. This is the total number of trials that the number of trials participated in is divided by to get the proportion of trials participated in

##Simulate the number of trials participated in for each site. Run a loop to multiply the proportion participated in by the total trials to convert it to the number of trials participated in per individual 
for (i in 1:(n/3)) {
  probability<-rnorm(1,site1mean,asd1)
  ifelse(probability>1,probability<-1,probability<-probability)
  testdata[i,]$participated<-round(testdata[i,]$totaltrials*probability,0)
}

for (i in ((n/3)+1):(2*n)/3) {
  probability<-rnorm(1,site2mean,asd2)
  ifelse(probability>1,probability<-1,probability<-probability)
  testdata[i,]$participated<-round(testdata[i,]$totaltrials*probability,0)
}

for (i in ((2*n/3)+1):n) {
  probability<-rnorm(1,site3mean,asd3)
  ifelse(probability>1,probability<-1,probability<-probability)
  testdata[i,]$participated<-round(testdata[i,]$totaltrials*probability,0)
}

testdata$optout <- testdata$totaltrials-testdata$participated #Populate the optout column: Calculate the trials not participated in: subtract participated in from the total

#RUN THE MODEL (this is the simulated data that the model (below) will use) Generate values for simulated individuals from 3 simulated sites: vary the alpha site mean (expected number of trials participated in and whether sites differ) and alpha sd (the noise in the population in the number of trials participated in), and sample size
dat_list <- list( participated = as.integer(testdata$participated),
                  totaltrials = as.integer(testdata$totaltrials),
                  site = as.integer(testdata$site) )

m1<-ulam(
  alist(
    participated ~ dbinom( totaltrials , p ) , 
    logit(p) <- a[site], 
    a[site] ~ dnorm (0,1.5)
    ) , data=dat_list , chains=4 )

#Plot it
post <- extract.samples(m1) 
probability <- inv_logit(post$a)
labels <- paste( "a[" , 1:3 , "]:" , levels(dat_list$site) , sep="" ) 
plot( precis( as.data.frame(probability) ) , xlim=c(0,1), labels=labels ,  xlab="proportion of trials participated in" ) #contrasts plot p.157

#Summary data
precis(m1,depth=2) #depth=2 means to show any vector parameters (p.156)

#Compute pairwise contrasts
#Comparing sites 1 and 2
post1 <- extract.samples(m1) 
post1$diff_12 <- inv_logit(post1$a[,1]) - inv_logit(post1$a[,2]) #subtract mu for site 2 from mu for site 1. col1=site 1, col2=site 2
precis(post1,depth=2) #look at the last row: diff_12: this is the expected difference between the distributions of mu at sites 1 and 2. (p.156) The distribution crosses 0, which means that there are no differences between the sites (because subtracting distribution 1 from distribution 2 should result in all negative or all positive values if the two distributions are consistently different from each other)

#Comparing sites 1 and 3
post2 <- extract.samples(m1) 
post2$diff_13 <- inv_logit(post2$a[,1]) - inv_logit(post2$a[,3]) 
precis(post2,depth=2)

#Comparing sites 2 and 3
post3 <- extract.samples(m1) 
post3$diff_23 <- inv_logit(post3$a[,2]) - inv_logit(post3$a[,3])
precis(post3,depth=2)
```

We then ran the **mathematical model** and performed pairwise contrasts and determined that we will be able to detect differences between sites with a sample size of 15 per site or 20 per site if the average proportion of trials participated in differs by at least 0.08 and the standard deviation is generally a maximum of 0.25 at each site (Table 2).

**Results (using our actual data)**

We will analyze our data using the above model once all of the data have been collected.


##### Repeatability of exploration and persistence

**Analysis:** We will obtain repeatability estimates that account for the observed and latent scales, and then compare them with the raw repeatability estimate from the null model. The repeatability estimate indicates how much of the total variance, after accounting for fixed and random effects, is explained by individual differences (bird ID). We will run this GLMM using the MCMCglmm function in the MCMCglmm package ([@hadfieldMCMCglmmpackage]) with a Poisson distribution and log link using 13,000 iterations with a thinning interval of 10, a burnin of 3,000, and minimal priors (V=1, nu=0) [@hadfield2014coursenotes]. We will ensure the GLMM shows acceptable convergence (i.e., lag time autocorrelation values <0.01; [@hadfieldMCMCglmmpackage]), and adjust parameters if necessary.

```{r repeatablePer, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
#Persistence
per <- read.csv ("/Users/corina/GTGR/data/data_persist.csv", header=T, sep=",", stringsAsFactors=F) 

# DATA CHECKING
library(DHARMa)
library(lme4)
simulationOutput <- simulateResiduals(fittedModel = glmer(NoParticipation ~ Test + (1|ID), family=poisson, data=per), n=250)
simulationOutput$scaledResiduals 
testDispersion(simulationOutput) 
testZeroInflation(simulationOutput) 
testUniformity(simulationOutput) 
plot(simulationOutput) 
plotResiduals(Test, simulationOutput$scaledResiduals) #can't get this code to work yet

#REPEATABILITY
#GLMM
library(MCMCglmm)
prior = list(R=list(R1=list(V=1,nu=0)), G=list(G1=list(V=1,nu=0)))
pers <- MCMCglmm(NoParticipation ~ Test, random=~ID, family="poisson", data=per, verbose=F, prior=prior, nitt=13000, thin=10, burnin=3000)
summary(pers)
#autocorr(pers$Sol) #Did fixed effects converge?
#autocorr(pers$VCV) #Did random effects converge?

#In MCMCglmm, the latent scale adjusted repeatability and its credible interval can simply be obtained by: mod$VCV[,ID]/(mod$VCV[,ID]+mod$VCV[,units]) - advice from Maxime Dahirel

repeata <- pers$VCV[,"ID"]/(pers$VCV[,"ID"]+pers$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval
mean(repeata) 
var(repeata) 
posterior.mode(repeata) 
HPDinterval(repeata, 0.95) 

# Repeatability on the data/observed scale (accounting for fixed effects)
#code from Supplementary Material S2 from Villemereuil et al. 2018 J Evol Biol
vf <- sapply(1:nrow(pers[["Sol"]]), function(i) {
   var(predict(pers, it=i))  
}) #estimates for each iteration of the MCMC

repeataF <- (vf+pers$VCV[,"ID"])/(vf+pers$VCV[,"ID"]+pers$VCV[,"units"]) #latent scale adjusted + data scale
posterior.mode(repeataF) 
HPDinterval(repeataF, 0.95)

# Now compare with the raw repeatability: null model
persraw <- MCMCglmm(NoParticipation ~ 1, random=~ID, family="poisson", data=per, verbose=F, prior=prior, nitt=13000, thin=10, burnin=3000)
summary(persraw)

repeataraw <- persraw$VCV[,"ID"]/(persraw$VCV[,"ID"]+persraw$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval
posterior.mode(repeata)
HPDinterval(repeata, 0.95) 
```

```{r repeatableExpObj, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
#Exploration of novel object
eo <- read.csv ("/Users/corina/GTGR/data/data_persist.csv", header=T, sep=",", stringsAsFactors=F) 

# DATA CHECKING
library(DHARMa)
library(lme4)
simulationOutput <- simulateResiduals(fittedModel = glmer(Latency ~ Time + (1|ID), family=poisson, data=eo), n=250) #250 simulations, but if want higher precision change n>1000
simulationOutput$scaledResiduals #Expect a flat distribution of the overall residuals, and uniformity in y direction if plotted against any predictor
testDispersion(simulationOutput) #if under- or over-dispersed, then p-value<0.05, but then check the dispersion parameter and try to determine what in the model could be the cause and address it there, also check for zero inflation
testZeroInflation(simulationOutput) #compare expected vs observed zeros, not zero-inflated if p<0.05
testUniformity(simulationOutput) #check for heteroscedasticity ("a systematic dependency of the dispersion / variance on another variable in the model" Hartig, https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html), which is indicated if dots aren't on the red line and p<0.05. Also...
plot(simulationOutput) #...there should be no pattern in the data points in the right panel
plotResiduals(Test, simulationOutput$scaledResiduals) #plot the residuals against other predictors (in cases when there is more than 1 fixed effect) - can't get this code to work yet

#REPEATABILITY
#GLMM
library(MCMCglmm)
prior = list(R=list(R1=list(V=1,nu=0)), G=list(G1=list(V=1,nu=0)))
explo <- MCMCglmm(Latency ~ Time, random=~ID, family="poisson", data=eo, verbose=F, prior=prior, nitt=13000, thin=10, burnin=3000)
summary(pers)
#autocorr(explo$Sol) #Did fixed effects converge?
#autocorr(explo$VCV) #Did random effects converge?

#In MCMCglmm, the latent scale adjusted repeatability and its credible interval can simply be obtained by: mod$VCV[,ID]/(mod$VCV[,ID]+mod$VCV[,units]) - advice from Maxime Dahirel

repeata <- explo$VCV[,"ID"]/(explo$VCV[,"ID"]+explo$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval
mean(repeata) 
var(repeata) 
posterior.mode(repeata) 
HPDinterval(repeata, 0.95) 

# Repeatability on the data/observed scale (accounting for fixed effects)
#code from Supplementary Material S2 from Villemereuil et al. 2018 J Evol Biol
vf <- sapply(1:nrow(explo[["Sol"]]), function(i) {
   var(predict(explo, it=i))  
}) #estimates for each iteration of the MCMC

repeataF <- (vf+explo$VCV[,"ID"])/(vf+explo$VCV[,"ID"]+explo$VCV[,"units"]) #latent scale adjusted + data scale
posterior.mode(repeataF) 
HPDinterval(repeataF, 0.95)

# Now compare with the raw repeatability: null model
exploraw <- MCMCglmm(Latency ~ 1, random=~ID, family="poisson", data=eo, verbose=F, prior=prior, nitt=13000, thin=10, burnin=3000)
summary(explraw)

repeataraw <- exploraw$VCV[,"ID"]/(exploraw$VCV[,"ID"]+exploraw$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval
posterior.mode(repeata)
HPDinterval(repeata, 0.95) 
```


#### H2: dispersal

*Response variable*

1) Average relatedness between all pairs of individuals within one sex

*Explanatory variables*

1) Site diameter (meters)

2) Site sample size

3) Number of generations at a site

One model will be run per sex

The data will be analyzed as in @sevchik2019dispersal. To summarize, blood is collected from the bird, DNA is extracted (by Aaron Blackwell at Washington State University), size selected (between 400-700 base pairs), and sequenced using ddRADseq (at Cornell University Lab of Ornithology) on an Illumina NextSeq500 machine using the mid-output setting for 150 base pair single end reads. Data are post processed to generate single nucleotide polymorphisms (SNPs) as in @thrasher2018double. Genetic relatedness between all pairs of individuals is calculated using the package “related” (@pew2015related) in R (as in @thrasher2018double). Permutations (i.e., randomly assigning site ID to individuals) and general linear models estimating average relatedness of each individual to all others at that site will be used to determine whether individuals at one site are more closely related to each other than the individuals at another site.

**Model and simulation**

Expected values for average relatedness per bird were based on the fact that average relatedness with these estimators has to range between -1 and 1 and because it is an average we expect a normal distribution.

averagerelatedness ~ $\alpha$[site] *[the model]*

$\alpha$[site] ~ Normal($\mu$,$\sigma$) *[$\alpha_1$ prior]*

$\mu$ ~ Normal(0,1) *[$\mu$ prior]*

$\sigma$ ~ Uniform(0,1) *[$\sigma$ prior]*




#### H3: suitable habitat

**P3: GTGR & BTGR use different habitats and GTGR's habitat has increased over time and P4: GTGR increased habitat breadth over time, but BTGR did not**

*Response variable:* Presence/absence of GTGR and BTGR

*Explanatory variable*

1) Land cover (e.g., forest, urban, crop land, coastal marsh, coastal prairie, coastal plain, grassland, brush, mangrove, distance from road/water body/wetland/water treatment plant)

2) Elevation

3) Climate (e.g., daily/annual temperature range)

4) Predator density

5) Distance to the next suitable habitat patch weighted by nearest mountain range/forest

6) Distance to the nearest conspecific population 10 years previous to the point in time being investigated

One model will be run for GTGR and a separate model will be run for BTGR

**Analysis**
 
 1) Download and preprocess eBird data. Conduct spatial filtering to account for sampling bias
 2) Clean the species occurrence data: remove any uncertain records or geographic outliers
 3) Import climactic variables from WorldClim and landscape data from MODIS and crop to region of interest
 4) Match environmental data to grackle occurrence records
 5) Fit models with maxent to get predicted distributions and estimate importance/contribution of each environmental variable

We will refer to @strimas2020bestpracticesebird [best practices for using eBird data](https://cornelllabofornithology.github.io/ebird-best-practices/) when extracting data on grackle presence in a region from eBird.org. We will gather environmental data from databases, including a database that maps global urban change from 1985-2015 to a high (30 m) resolution (@liu2020high). We will use a variety of R packages, including auk (@auk), dismo (@dismo), raster (@raster), maptools (@maptools), tidyverse (@tidyverse), rgdal (@rgdal), rJava (@rjava), and elevatr (@elevatr).

```{r hab, eval=FALSE, warning=FALSE, results='asis', echo=TRUE, include=TRUE}
#Load packages
library(auk)
library(dismo)
library(raster)
library(maptools)
library(tidyverse)
library(rgdal)
library(rJava)

#Get citations for packages
options(citation.bibtex.max=999) #this makes it so that citation() only shows up in bibtex format
citation("elevatr")
citation("auk")
citation("dismo")
citation("raster")
citation("maptools")
citation("tidyverse")
citation("rgdal")
citation("rJava")

d <-read.csv("gtgr_points.csv", header = T)
```


### F. ETHICS

This research is carried out in accordance with permits from the:

1) US Fish and Wildlife Service (scientific collecting permit number MB76700A-0,1,2)
2) US Geological Survey Bird Banding Laboratory (federal bird banding permit number 23872)
3) Arizona Game and Fish Department (scientific collecting license number SP594338 [2017], SP606267 [2018], SP639866 [2019], and SP402153 [2020])
4) Institutional Animal Care and Use Committee at Arizona State University (protocol number 17-1594R)
5) California Department of Fish and Wildlife (scientific collecting permit [specific use] number S‐192100001‐19210‐001)

### G. AUTHOR CONTRIBUTIONS

**Logan:** Hypothesis development, data collection (H1 & H2), data analysis and interpretation, write up, revising/editing, materials/funding.

**McCune:** Method development, data collection (H1 & H2), data analysis and interpretation, revising/editing.

**Breen:** Data collection (H1 & H2), data analysis and interpretation, revising/editing.

**Chen (H3):** Hypothesis development, data collection, ecological niche modeling, data interpretation, revising/editing.

**Lukas:** Hypothesis development, data analysis and interpretation, write up, revising/editing.

### H. FUNDING

This research is funded by the Department of Human Behavior, Ecology and Culture at the Max Planck Institute for Evolutionary Anthropology.

### I. CONFLICT OF INTEREST DISCLOSURE

We, the authors, declare that we have no financial conflicts of interest with the content of this article. CJ Logan and D Lukas are Recommenders at PCI Ecology, and CJ Logan is on the Managing Board at PCI Ecology.

### J. ACKNOWLEDGEMENTS

We thank Kristine Johnson for technical advice on great-tailed grackles; Julia Cissewski and Sophie Kaube for tirelessly solving problems involving financial transactions and contracts; and Richard McElreath for project support.

### K. [REFERENCES](MyLibrary.bib)
